# Perfect Number Network - Nginx Reverse Proxy Configuration
# This configuration supports multiple hosting scenarios:
# - Local network access (IP-based)
# - DuckDNS or other dynamic DNS
# - AWS/Cloud hosting with domain
# - Direct IP access without domain
#
# SETUP INSTRUCTIONS:
# 1. Copy to: /etc/nginx/sites-available/perfectnet
# 2. Edit SERVER_NAME below to match your setup
# 3. Enable: sudo ln -s /etc/nginx/sites-available/perfectnet /etc/nginx/sites-enabled/
# 4. Test: sudo nginx -t
# 5. Reload: sudo systemctl reload nginx

# =============================================================================
# CONFIGURATION - EDIT THESE VARIABLES
# =============================================================================
# Replace with your domain, DuckDNS hostname, or server IP
# Examples:
#   perfectnet.example.com
#   myserver.duckdns.org
#   192.168.1.100
#   10.0.0.50
#   _  (underscore = accept any hostname/IP - least secure but most flexible)

# SERVER_NAME: Set your domain/hostname/IP here
# For local network only: Use your server's IP (e.g., 192.168.1.100)
# For DuckDNS: Use your DuckDNS hostname (e.g., myserver.duckdns.org)
# For public domain: Use your domain (e.g., perfectnet.example.com)
# For maximum flexibility: Use _ (accepts any hostname)

# Backend ports - change if you modified the Flask apps
upstream perfectnet_api {
    server 127.0.0.1:5000 fail_timeout=30s max_fails=3;
}

upstream perfectnet_dashboard {
    server 127.0.0.1:8080 fail_timeout=30s max_fails=3;
}

# =============================================================================
# SCENARIO 1: HTTPS with SSL Certificate (Production)
# Use this for public domains with Let's Encrypt or other SSL certificates
# =============================================================================

# HTTP to HTTPS redirect
server {
    listen 80;
    listen [::]:80;
    
    # EDIT THIS: Your domain/hostname
    server_name perfectnet.example.com;
    # For DuckDNS: server_name myserver.duckdns.org;
    # For any host: server_name _;
    
    # Let's Encrypt ACME challenge
    location /.well-known/acme-challenge/ {
        root /var/www/certbot;
    }
    
    # Redirect all other HTTP to HTTPS
    location / {
        return 301 https://$server_name$request_uri;
    }
}

# HTTPS Server
server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    
    # EDIT THIS: Your domain/hostname (same as above)
    server_name perfectnet.example.com;
    # For DuckDNS: server_name myserver.duckdns.org;
    # For any host: server_name _;

    # =============================================================================
    # SSL CERTIFICATE CONFIGURATION
    # =============================================================================
    # 
    # OPTION A: Let's Encrypt (Recommended for public domains)
    # Uncomment these lines after running: sudo certbot --nginx -d your-domain.com
    # ssl_certificate /etc/letsencrypt/live/perfectnet.example.com/fullchain.pem;
    # ssl_certificate_key /etc/letsencrypt/live/perfectnet.example.com/privkey.pem;
    # include /etc/letsencrypt/options-ssl-nginx.conf;
    # ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;
    
    # OPTION B: Self-Signed Certificate (Testing/Local Network)
    # Generate with: sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
    #   -keyout /etc/ssl/private/perfectnet-selfsigned.key \
    #   -out /etc/ssl/certs/perfectnet-selfsigned.crt
    ssl_certificate /etc/ssl/certs/ssl-cert-snakeoil.pem;
    ssl_certificate_key /etc/ssl/private/ssl-cert-snakeoil.key;
    
    # OPTION C: Commercial SSL Certificate
    # ssl_certificate /path/to/your/fullchain.pem;
    # ssl_certificate_key /path/to/your/private.key;

    # SSL Configuration (Mozilla Intermediate - Compatible with most clients)
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;
    ssl_session_timeout 1d;
    ssl_session_cache shared:MozSSL:10m;
    ssl_session_tickets off;
    ssl_stapling on;
    ssl_stapling_verify on;

    # Security Headers
    add_header Strict-Transport-Security "max-age=63072000; includeSubDomains" always;
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;

    # Logging
    access_log /var/log/nginx/perfectnet_access.log combined;
    error_log /var/log/nginx/perfectnet_error.log warn;

    # Client body size (for large perfect number submissions)
    client_max_body_size 10M;

    # API Endpoints (Flask Server)
    location /api/ {
        proxy_pass http://perfectnet_api;
        proxy_http_version 1.1;
        
        # Preserve client information
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Host $host;
        proxy_set_header X-Forwarded-Port $server_port;
        
        # CORS headers (if needed beyond Flask-CORS)
        add_header Access-Control-Allow-Origin * always;
        add_header Access-Control-Allow-Methods "GET, POST, OPTIONS" always;
        add_header Access-Control-Allow-Headers "X-API-Key, Content-Type" always;
        
        # Handle OPTIONS preflight
        if ($request_method = OPTIONS) {
            return 204;
        }
        
        # Timeouts (important for long computations)
        proxy_connect_timeout 60s;
        proxy_send_timeout 300s;
        proxy_read_timeout 300s;
        
        # Buffering
        proxy_buffering off;
        proxy_request_buffering off;
        
        # Error handling
        proxy_intercept_errors off;
    }

    # Dashboard (Flask Dashboard)
    location / {
        proxy_pass http://perfectnet_dashboard;
        proxy_http_version 1.1;
        
        # Preserve client information
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # WebSocket support (for future real-time updates)
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        
        # Timeouts
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
        
        # Buffering
        proxy_buffering on;
    }

    # Health check endpoint (no auth, no logging spam)
    location /health {
        proxy_pass http://perfectnet_dashboard/health;
        access_log off;
        error_log /dev/null;
    }

    # Deny access to hidden files and directories
    location ~ /\. {
        deny all;
        access_log off;
        log_not_found off;
    }
}

# =============================================================================
# SCENARIO 2: HTTP ONLY (Local Network/Testing)
# Use this for local network access without SSL
# Comment out the HTTPS server block above and uncomment this
# =============================================================================

# server {
#     listen 80;
#     listen [::]:80;
#     
#     # Accept any hostname/IP
#     server_name _;
#     
#     # Logging
#     access_log /var/log/nginx/perfectnet_access.log combined;
#     error_log /var/log/nginx/perfectnet_error.log warn;
#     
#     # Client body size
#     client_max_body_size 10M;
#     
#     # API Endpoints
#     location /api/ {
#         proxy_pass http://perfectnet_api;
#         proxy_http_version 1.1;
#         proxy_set_header Host $host;
#         proxy_set_header X-Real-IP $remote_addr;
#         proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
#         proxy_set_header X-Forwarded-Proto $scheme;
#         proxy_connect_timeout 60s;
#         proxy_send_timeout 300s;
#         proxy_read_timeout 300s;
#         proxy_buffering off;
#     }
#     
#     # Dashboard
#     location / {
#         proxy_pass http://perfectnet_dashboard;
#         proxy_http_version 1.1;
#         proxy_set_header Host $host;
#         proxy_set_header X-Real-IP $remote_addr;
#         proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
#         proxy_set_header Upgrade $http_upgrade;
#         proxy_set_header Connection "upgrade";
#     }
#     
#     # Health check
#     location /health {
#         proxy_pass http://perfectnet_dashboard/health;
#         access_log off;
#     }
# }

# =============================================================================
# RATE LIMITING (Optional - Recommended for Public Servers)
# Add to /etc/nginx/nginx.conf in the http {} block
# =============================================================================
#
# http {
#     # Rate limit zones
#     limit_req_zone $binary_remote_addr zone=api_limit:10m rate=10r/s;
#     limit_req_zone $binary_remote_addr zone=dashboard_limit:10m rate=30r/s;
#     limit_req_zone $binary_remote_addr zone=registration_limit:10m rate=5r/m;
#     
#     # Connection limits
#     limit_conn_zone $binary_remote_addr zone=conn_limit:10m;
# }
#
# Then add to location blocks in the server configuration above:
#
# location /api/register {
#     limit_req zone=registration_limit burst=2 nodelay;
#     proxy_pass http://perfectnet_api;
#     # ... rest of proxy config
# }
#
# location /api/ {
#     limit_req zone=api_limit burst=20 nodelay;
#     limit_conn conn_limit 10;
#     proxy_pass http://perfectnet_api;
#     # ... rest of proxy config
# }
#
# location / {
#     limit_req zone=dashboard_limit burst=50 nodelay;
#     proxy_pass http://perfectnet_dashboard;
#     # ... rest of proxy config
# }

# =============================================================================
# QUICK SETUP GUIDES
# =============================================================================

# --- LOCAL NETWORK (HTTP ONLY) ---
# 1. Use the HTTP ONLY server block above
# 2. Set server_name to _ or your local IP
# 3. Access via http://YOUR_SERVER_IP
# 4. No SSL needed

# --- DUCKDNS SETUP ---
# 1. Create DuckDNS account and subdomain: https://www.duckdns.org
# 2. Install DuckDNS updater:
#    curl -s 'https://www.duckdns.org/update?domains=YOURSUBDOMAIN&token=YOURTOKEN&ip=' | cron
# 3. Set server_name to: mysubdomain.duckdns.org
# 4. Get Let's Encrypt cert:
#    sudo certbot --nginx -d mysubdomain.duckdns.org
# 5. Port forward 80 and 443 on your router

# --- AWS/CLOUD WITH DOMAIN ---
# 1. Point your domain A record to server IP
# 2. Set server_name to: yourdomain.com
# 3. Get Let's Encrypt cert:
#    sudo certbot --nginx -d yourdomain.com
# 4. Configure security groups (AWS) or firewall:
#    - Allow inbound 80/tcp and 443/tcp
#    - Block direct access to 5000/tcp and 8080/tcp

# --- CLOUDFLARE WITH DUCKDNS ---
# 1. Set up DuckDNS as above
# 2. Add DuckDNS subdomain to Cloudflare as CNAME
# 3. Enable Cloudflare proxy (orange cloud)
# 4. Use Cloudflare SSL (Flexible or Full)
# 5. No Let's Encrypt needed (Cloudflare handles SSL)

# --- LET'S ENCRYPT CERTIFICATE SETUP ---
# Install certbot:
#   Ubuntu/Debian: sudo apt install certbot python3-certbot-nginx
#   RHEL/CentOS: sudo yum install certbot python3-certbot-nginx
#
# Get certificate:
#   sudo certbot --nginx -d your-domain.com
#
# Auto-renewal (already set up):
#   Test: sudo certbot renew --dry-run
#
# Certificate location:
#   /etc/letsencrypt/live/your-domain.com/fullchain.pem
#   /etc/letsencrypt/live/your-domain.com/privkey.pem

# --- FIREWALL CONFIGURATION ---
# UFW (Ubuntu):
#   sudo ufw allow 'Nginx Full'  # Allows 80 and 443
#   sudo ufw deny 5000/tcp       # Block direct Flask access
#   sudo ufw deny 8080/tcp       # Block direct Dashboard access
#   sudo ufw enable
#
# firewalld (RHEL/CentOS):
#   sudo firewall-cmd --permanent --add-service=http
#   sudo firewall-cmd --permanent --add-service=https
#   sudo firewall-cmd --permanent --remove-port=5000/tcp
#   sudo firewall-cmd --permanent --remove-port=8080/tcp
#   sudo firewall-cmd --reload
#
# AWS Security Group:
#   Inbound: 80/tcp from 0.0.0.0/0
#   Inbound: 443/tcp from 0.0.0.0/0
#   Outbound: All traffic

# --- TESTING ---
# Test nginx config:
#   sudo nginx -t
#
# Reload nginx:
#   sudo systemctl reload nginx
#
# Check logs:
#   sudo tail -f /var/log/nginx/perfectnet_error.log
#   sudo tail -f /var/log/nginx/perfectnet_access.log
#
# Test endpoints:
#   curl http://localhost/api/health
#   curl http://localhost/health
#   curl -k https://localhost/api/health  # -k for self-signed certs

# --- TROUBLESHOOTING ---
# Backend not responding:
#   - Check Flask apps are running: sudo systemctl status perfectnet-*
#   - Check ports: sudo netstat -tlnp | grep -E '5000|8080'
#   - Check Flask logs: sudo journalctl -u perfectnet-server -f
#
# SSL certificate errors:
#   - Verify cert paths: ls -la /etc/letsencrypt/live/your-domain/
#   - Check cert expiry: sudo certbot certificates
#   - Renew manually: sudo certbot renew
#
# 502 Bad Gateway:
#   - Flask apps not running or crashed
#   - Wrong upstream ports in nginx config
#   - Check: curl http://127.0.0.1:5000/api/health
#
# Connection refused:
#   - Firewall blocking ports
#   - Nginx not running: sudo systemctl status nginx
#   - Port conflicts: sudo netstat -tlnp | grep -E '80|443'
